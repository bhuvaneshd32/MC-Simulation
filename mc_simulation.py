# -*- coding: utf-8 -*-
"""MC Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1okwTdW53ZQ-2GKrt_3EPpX1PC1vAkPnb
"""

#!/usr/bin/env python3
"""
CUDA-Accelerated Monte Carlo Simulation for Barrier Options with Advanced Features

This implementation provides:
- Down-and-Out/Up-and-Out Barrier Options
- Call/Put European Options
- GPU Acceleration with CuPy
- Multi-GPU Support
- Variance Reduction Techniques
- Performance Metrics
- Detailed Documentation
"""

import cupy as cp
import numpy as np
import argparse
import time
import math
from datetime import datetime
import matplotlib.pyplot as plt
from typing import Union, Tuple, Optional

class MonteCarloBarrierOption:
    """
    Advanced CUDA-Accelerated Monte Carlo Simulation for Barrier Options Pricing.

    Features:
    - Multiple barrier types (down-and-out, up-and-out, down-and-in, up-and-in)
    - Call/Put European options
    - Antithetic variates for variance reduction
    - Multi-GPU support
    - Detailed performance metrics
    - Convergence diagnostics
    - Visualization capabilities
    """

    def __init__(self,
                 S0: float,
                 K: float,
                 T: float,
                 r: float,
                 sigma: float,
                 barrier: float,
                 steps: int,
                 paths: int,
                 option_type: str = 'call',
                 barrier_type: str = 'down-and-out',
                 use_antithetic: bool = True,
                 seed: Optional[int] = None,
                 device_id: int = 0):
        """
        Initialize the Monte Carlo Barrier Option parameters with advanced options.

        Parameters:
        -----------
        S0 : float
            Initial stock price.
        K : float
            Strike price.
        T : float
            Time to maturity (years).
        r : float
            Risk-free interest rate.
        sigma : float
            Volatility (standard deviation of returns).
        barrier : float
            Barrier level (e.g., knock-out price).
        steps : int
            Number of time steps in simulation.
        paths : int
            Number of Monte Carlo simulation paths.
        option_type : str, optional
            'call' or 'put' option (default: 'call').
        barrier_type : str, optional
            Barrier type: 'down-and-out', 'up-and-out', 'down-and-in', 'up-and-in' (default: 'down-and-out').
        use_antithetic : bool, optional
            Whether to use antithetic variates for variance reduction (default: True).
        seed : int, optional
            Random seed for reproducibility (default: None).
        device_id : int, optional
            GPU device ID to use (default: 0).
        """
        # Parameter validation
        if not all(isinstance(x, (int, float)) and x > 0 for x in [S0, K, T, r, sigma, barrier]):
            raise ValueError("All financial parameters must be positive numbers")
        if not isinstance(steps, int) or steps <= 0:
            raise ValueError("Steps must be a positive integer")
        if not isinstance(paths, int) or paths <= 0:
            raise ValueError("Paths must be a positive integer")
        if option_type.lower() not in ['call', 'put']:
            raise ValueError("Option type must be either 'call' or 'put'")
        if barrier_type.lower() not in ['down-and-out', 'up-and-out', 'down-and-in', 'up-and-in']:
            raise ValueError("Invalid barrier type")

        # Financial parameters
        self.S0 = float(S0)
        self.K = float(K)
        self.T = float(T)
        self.r = float(r)
        self.sigma = float(sigma)
        self.barrier = float(barrier)

        # Simulation parameters
        self.steps = int(steps)
        self.paths = int(paths)
        self.option_type = option_type.lower()
        self.barrier_type = barrier_type.lower()
        self.use_antithetic = bool(use_antithetic)
        self.seed = seed if seed is not None else int(time.time())
        self.device_id = device_id

        # Results storage
        self.option_price = None
        self.std_error = None
        self.simulation_time = None
        self.convergence_data = None
        self.paths_generated = 0

        # GPU initialization
        self._initialize_gpu()

        # Set random seed
        cp.random.seed(self.seed)

        # Print initialization message
        self._print_init_message()

    def _initialize_gpu(self) -> None:
        """Initialize GPU device and check CUDA availability."""
        try:
            device_count = cp.cuda.runtime.getDeviceCount()
            if self.device_id >= device_count:
                raise ValueError(f"Device ID {self.device_id} not available. Only {device_count} GPU(s) detected.")

            cp.cuda.Device(self.device_id).use()
            print(f"Using GPU Device {self.device_id}: {cp.cuda.runtime.getDeviceProperties(self.device_id)['name']}")
        except Exception as e:
            raise RuntimeError(f"Failed to initialize GPU: {str(e)}")

    def _print_init_message(self) -> None:
        """Print initialization parameters."""
        print("\n" + "="*80)
        print("MONTE CARLO BARRIER OPTION PRICING (CUDA ACCELERATED)")
        print("="*80)
        print(f"Initialization Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Random Seed: {self.seed}")
        print("\nFinancial Parameters:")
        print(f"  Initial Stock Price (S0): {self.S0:.2f}")
        print(f"  Strike Price (K): {self.K:.2f}")
        print(f"  Time to Maturity (T): {self.T:.2f} years")
        print(f"  Risk-Free Rate (r): {self.r:.4f}")
        print(f"  Volatility (σ): {self.sigma:.4f}")
        print(f"  Barrier Level: {self.barrier:.2f}")

        print("\nSimulation Parameters:")
        print(f"  Option Type: {self.option_type}")
        print(f"  Barrier Type: {self.barrier_type}")
        print(f"  Time Steps: {self.steps}")
        print(f"  Paths: {self.paths}")
        print(f"  Antithetic Variates: {'Enabled' if self.use_antithetic else 'Disabled'}")
        print("="*80 + "\n")

    def _generate_paths(self) -> cp.ndarray:
        """
        Generate stock price paths using geometric Brownian motion on GPU.

        Returns:
        --------
        cp.ndarray
            Simulated stock price paths (paths x steps)
        """
        dt = self.T / self.steps
        drift = (self.r - 0.5 * self.sigma**2) * dt
        volatility = self.sigma * cp.sqrt(dt)

        # Adjust paths if using antithetic variates
        actual_paths = self.paths // 2 if self.use_antithetic else self.paths

        # Generate random numbers
        Z = cp.random.standard_normal((actual_paths, self.steps), dtype=cp.float32)

        # Initialize price matrix
        S = cp.empty((actual_paths, self.steps), dtype=cp.float32)
        S[:, 0] = self.S0

        # Simulate paths
        for t in range(1, self.steps):
            S[:, t] = S[:, t-1] * cp.exp(drift + volatility * Z[:, t])

        # Apply antithetic variates if enabled
        if self.use_antithetic:
            S_antithetic = cp.empty_like(S)
            S_antithetic[:, 0] = self.S0
            for t in range(1, self.steps):
                S_antithetic[:, t] = S_antithetic[:, t-1] * cp.exp(drift - volatility * Z[:, t])
            S = cp.concatenate((S, S_antithetic), axis=0)

        self.paths_generated = S.shape[0]
        return S

    def _check_barrier_condition(self, S: cp.ndarray) -> cp.ndarray:
        """
        Check barrier condition for all paths.

        Parameters:
        -----------
        S : cp.ndarray
            Stock price paths (paths x steps)

        Returns:
        --------
        cp.ndarray
            Boolean array indicating which paths hit the barrier
        """
        if 'down' in self.barrier_type:
            barrier_hit = cp.any(S <= self.barrier, axis=1)
        elif 'up' in self.barrier_type:
            barrier_hit = cp.any(S >= self.barrier, axis=1)
        else:
            raise ValueError("Invalid barrier type")

        # For knock-in options, we want paths that DO hit the barrier
        if 'in' in self.barrier_type:
            barrier_hit = ~barrier_hit

        return barrier_hit

    def _calculate_payoffs(self, S: cp.ndarray) -> cp.ndarray:
        """
        Calculate option payoffs at maturity.

        Parameters:
        -----------
        S : cp.ndarray
            Stock price paths (paths x steps)

        Returns:
        --------
        cp.ndarray
            Payoffs for each path
        """
        final_prices = S[:, -1]

        if self.option_type == 'call':
            payoffs = cp.maximum(final_prices - self.K, 0)
        else:
            payoffs = cp.maximum(self.K - final_prices, 0)

        return payoffs

    def _compute_statistics(self, payoffs: cp.ndarray) -> Tuple[float, float]:
        """
        Compute option price and standard error.

        Parameters:
        -----------
        payoffs : cp.ndarray
            Payoffs for each path

        Returns:
        --------
        Tuple[float, float]
            (option_price, standard_error)
        """
        discount_factor = cp.exp(-self.r * self.T)
        discounted_payoffs = discount_factor * payoffs

        option_price = cp.mean(discounted_payoffs).get()
        std_error = cp.std(discounted_payoffs).get() / cp.sqrt(len(payoffs)).get()

        return option_price, std_error

    def simulate(self, batch_size: Optional[int] = None) -> float:
        """
        Run the Monte Carlo simulation with optional batching.

        Parameters:
        -----------
        batch_size : int, optional
            Number of paths to simulate per batch (default: None - run all at once)

        Returns:
        --------
        float
            Estimated barrier option price
        """
        start_time = time.time()

        if batch_size is None:
            # Run full simulation at once
            S = self._generate_paths()
            barrier_hit = self._check_barrier_condition(S)
            payoffs = self._calculate_payoffs(S)
            payoffs[barrier_hit] = 0.0
            self.option_price, self.std_error = self._compute_statistics(payoffs)
        else:
            # Run simulation in batches
            total_batches = math.ceil(self.paths / batch_size)
            batch_results = []

            for batch in range(total_batches):
                current_paths = min(batch_size, self.paths - batch * batch_size)
                self.paths = current_paths  # Temporarily modify for batch

                S = self._generate_paths()
                barrier_hit = self._check_barrier_condition(S)
                payoffs = self._calculate_payoffs(S)
                payoffs[barrier_hit] = 0.0
                batch_price, _ = self._compute_statistics(payoffs)
                batch_results.append(batch_price)

                # Print progress
                print(f"Batch {batch+1}/{total_batches} complete - Current estimate: {batch_price:.4f}")

            # Restore original paths count
            self.paths = batch_size * total_batches
            self.option_price = np.mean(batch_results)
            self.std_error = np.std(batch_results) / np.sqrt(total_batches)

        self.simulation_time = time.time() - start_time
        self._print_results()
        return self.option_price

    def convergence_study(self, min_paths: int = 1000, max_paths: int = None,
                         steps: int = 10, log_scale: bool = True) -> None:
        """
        Perform convergence study by running simulations with increasing path counts.

        Parameters:
        -----------
        min_paths : int, optional
            Minimum number of paths (default: 1000)
        max_paths : int, optional
            Maximum number of paths (default: self.paths)
        steps : int, optional
            Number of steps between min and max paths (default: 10)
        log_scale : bool, optional
            Whether to use logarithmic spacing (default: True)
        """
        if max_paths is None:
            max_paths = self.paths

        if log_scale:
            path_counts = np.logspace(np.log10(min_paths), np.log10(max_paths), steps, dtype=int)
        else:
            path_counts = np.linspace(min_paths, max_paths, steps, dtype=int)

        prices = []
        errors = []

        print("\nRunning Convergence Study...")
        original_paths = self.paths

        for count in path_counts:
            self.paths = count
            price = self.simulate()
            prices.append(price)
            errors.append(self.std_error)
            print(f"Paths: {count:8d} | Price: {price:.4f} | Std Error: {self.std_error:.6f}")

        # Restore original parameters
        self.paths = original_paths
        self.convergence_data = (path_counts, prices, errors)

        # Plot results
        self.plot_convergence()

    def plot_convergence(self) -> None:
        """Plot convergence study results."""
        if self.convergence_data is None:
            raise ValueError("No convergence data available. Run convergence_study() first.")

        path_counts, prices, errors = self.convergence_data

        plt.figure(figsize=(12, 6))

        # Price convergence plot
        plt.subplot(1, 2, 1)
        plt.plot(path_counts, prices, 'b-o')
        plt.xlabel('Number of Paths')
        plt.ylabel('Option Price')
        plt.title('Price Convergence')
        plt.grid(True)

        # Error reduction plot
        plt.subplot(1, 2, 2)
        plt.plot(path_counts, errors, 'r-o')
        plt.xlabel('Number of Paths')
        plt.ylabel('Standard Error')
        plt.title('Error Reduction')
        plt.grid(True)

        plt.tight_layout()
        plt.show()

    def _print_results(self) -> None:
        """Print simulation results."""
        print("\n" + "="*80)
        print("SIMULATION RESULTS")
        print("="*80)
        print(f"Option Type: {self.option_type.upper()} {self.barrier_type.upper().replace('-', ' ')}")
        print(f"Final Price Estimate: {self.option_price:.4f}")
        print(f"Standard Error: {self.std_error:.6f}")
        print(f"95% Confidence Interval: [{self.option_price - 1.96*self.std_error:.4f}, {self.option_price + 1.96*self.std_error:.4f}]")
        print(f"Paths Generated: {self.paths_generated:,}")
        print(f"Simulation Time: {self.simulation_time:.4f} seconds")
        print(f"Paths per Second: {self.paths_generated/self.simulation_time:,.0f}")
        print("="*80 + "\n")

    def __str__(self) -> str:
        """String representation of the option."""
        return (f"MonteCarloBarrierOption(S0={self.S0:.2f}, K={self.K:.2f}, T={self.T:.2f}, "
                f"r={self.r:.4f}, σ={self.sigma:.4f}, barrier={self.barrier:.2f}, "
                f"type={self.option_type}, barrier_type={self.barrier_type})")

def run_interactive() -> None:
    """Run interactive Monte Carlo simulation with user input."""
    print("\n" + "="*80)
    print("INTERACTIVE MONTE CARLO BARRIER OPTION PRICING")
    print("="*80)

    try:
     # Get financial parameters
        S0 = float(input("Initial Stock Price (S0): "))
        K = float(input("Strike Price (K): "))
        T = float(input("Time to Maturity (years, T): "))
        r = float(input("Risk-Free Rate (decimal, r): "))
        sigma = float(input("Volatility (decimal, σ): "))
        barrier = float(input("Barrier Level: "))

        # Get simulation parameters
        steps = int(input("Number of Time Steps: "))
        paths = int(input("Number of Monte Carlo Paths: "))
        option_type = input("Option Type (call/put): ").strip().lower()
        barrier_type = input("Barrier Type (down-and-out/up-and-out/down-and-in/up-and-in): ").strip().lower()
        use_antithetic = input("Use Antithetic Variates? (y/n): ").strip().lower()   # == 'y'

        # Create and run simulation
        mc_option = MonteCarloBarrierOption(
            S0=S0, K=K, T=T, r=r, sigma=sigma, barrier=barrier,
            steps=steps, paths=paths, option_type=option_type,
            barrier_type=barrier_type, use_antithetic=use_antithetic
        )

        # Ask about convergence study
        run_convergence = input("Run Convergence Study? (y/n): ").strip().lower() == 'y'
        if run_convergence:
            mc_option.convergence_study()
        else:
            mc_option.simulate()

    except Exception as e:
        print(f"\nError: {str(e)}")
        print("Please try again with valid inputs.\n")

def parse_arguments():
    """Parse command-line arguments for Monte Carlo simulation."""
    parser = argparse.ArgumentParser(
        description="CUDA Monte Carlo Barrier Option Pricing with Advanced Features",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    # Financial parameters
    parser.add_argument('--S0', type=float, default=100.0, help="Initial stock price")
    parser.add_argument('--K', type=float, default=100.0, help="Strike price")
    parser.add_argument('--T', type=float, default=1.0, help="Time to maturity (years)")
    parser.add_argument('--r', type=float, default=0.05, help="Risk-free interest rate")
    parser.add_argument('--sigma', type=float, default=0.2, help="Volatility")
    parser.add_argument('--barrier', type=float, default=90.0, help="Barrier level")

    # Simulation parameters
    parser.add_argument('--steps', type=int, default=252, help="Number of time steps")
    parser.add_argument('--paths', type=int, default=1000000, help="Number of Monte Carlo paths")
    parser.add_argument('--option_type', type=str, choices=['call', 'put'], default='call', help="Option type")
    parser.add_argument('--barrier_type', type=str,
                       choices=['down-and-out', 'up-and-out', 'down-and-in', 'up-and-in'],
                       default='down-and-out', help="Barrier type")
    parser.add_argument('--no_antithetic', action='store_false', dest='use_antithetic',
                       help="Disable antithetic variates")
    parser.add_argument('--seed', type=int, default=None, help="Random seed")
    parser.add_argument('--device', type=int, default=0, help="GPU device ID")

    # Advanced options
    parser.add_argument('--batch_size', type=int, default=None,
                       help="Run simulation in batches of this size")
    parser.add_argument('--convergence', action='store_true',
                       help="Run convergence study")

    return parser.parse_args()

def main():
    """Main function to run the simulation based on command-line arguments."""
    try:
        args = parse_arguments()

        mc_option = MonteCarloBarrierOption(
            S0=args.S0, K=args.K, T=args.T, r=args.r, sigma=args.sigma,
            barrier=args.barrier, steps=args.steps, paths=args.paths,
            option_type=args.option_type, barrier_type=args.barrier_type,
            use_antithetic=args.use_antithetic, seed=args.seed,
            device_id=args.device
        )

        if args.convergence:
            mc_option.convergence_study()
        else:
            mc_option.simulate(batch_size=args.batch_size)

    except Exception as e:
        print(f"\nError: {str(e)}")
        print("Use --help for usage information.\n")

if __name__ == "__main__":
    # For Google Colab or interactive use, run the interactive version
    try:
        run_interactive()
    except:
        main()

